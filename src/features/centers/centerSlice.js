import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import { create, deleteCenter, getAllCenters, update } from './centerApi';



export const fetchAllCenters = createAsyncThunk(
  'center/allCenters',
  async ({ token, page}) => {
    const response = await getAllCenters({ token, page });
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

// export const fetchGroupedPermissions = createAsyncThunk(
//   'permission/groupedPermissions',
//   async (token) => {
//     const response = await getAllGroupedPermissions(token);
//     // The value we return becomes the `fulfilled` action payload
//     return response.data;
//   }
// );


export const fetchCreateCenter = createAsyncThunk(
  'center/create',
  async ({ token,centerData }) => {
    const response = await create({token , centerData});
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const fetchUpdateCenter = createAsyncThunk(
  'center/update',
  async ({ token,centerData }) => {
    const response = await update({token , centerData});
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const fetchDeleteCenter = createAsyncThunk(
  'center/delete',
  async ({ token,Id }) => {
    const response = await deleteCenter({token , Id});
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);



export const centerSlice = createSlice({
  name: 'center',
  initialState:{
    value: 0,
    centers:[],
    currentPage: 1,
    totalPages: 1,
    totalRecords: 0,
    loading: false,
    isCenterCreate:null,
  },
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
   setAuthFromStorage: (state, action) => {
      state.token = action.payload.token;
      state.isAuthenticated = true;
    },
    setUpdateStatus: (state, action) => {
      state.isCenterCreate = null;
    },
    setCurrentPage: (state, action) => {
      state.currentPage = action.payload;
    },
    
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
     
      .addCase(fetchAllCenters.pending, (state) => {
         state.loading = true;       
      })
      .addCase(fetchAllCenters.fulfilled, (state, action) => {
          state.loading = false;
          state.centers = action.payload.data.centers;
          state.currentPage = action.payload.data.pagination.current_page;
        state.totalPages = action.payload.data.pagination.last_page;
        state.totalRecords = action.payload.data.pagination.total;
      }).addCase(fetchAllCenters.rejected, (state ,action) => { 
          state.loading = false;
      })
      
      .addCase(fetchCreateCenter.pending, (state) => {
        state.isCenterCreate = 'pending';
      })
      .addCase(fetchCreateCenter.fulfilled, (state, action) => {
          state.isCenterCreate = 'create';
      }).addCase(fetchCreateCenter.rejected, (state ,action) => {
        state.isCenterCreate = 'error';
      })
      
       .addCase(fetchUpdateCenter.pending, (state) => {
        state.isCenterCreate = 'pending';
      })
      .addCase(fetchUpdateCenter.fulfilled, (state, action) => {
          state.isCenterCreate = 'update';
      }).addCase(fetchUpdateCenter.rejected, (state ,action) => {
        state.isCenterCreate = 'error';
      })
      
      .addCase(fetchDeleteCenter.pending, (state) => {
        state.isCenterCreate = 'pending';
      })
      .addCase(fetchDeleteCenter.fulfilled, (state, action) => {
          state.isCenterCreate = 'delete';
      }).addCase(fetchDeleteCenter.rejected, (state ,action) => {
        state.isCenterCreate = 'error';
      })

      ;
      
  },
});

export const { setAuthFromStorage , setUpdateStatus , setCurrentPage} = centerSlice.actions;


export default centerSlice.reducer;
