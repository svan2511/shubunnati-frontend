import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import { create, deleteUser, fetchLoginUser, fetchLogoutUser, getAllRoles, getAllUsers, update } from './userAuthApi';

export const fetchUserLogin = createAsyncThunk(
  'user/login',
  async (data) => {
    const response = await fetchLoginUser(data);
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const fetchUserLogout = createAsyncThunk(
  'user/logout',
  async (data) => {
    const response = await fetchLogoutUser(data);
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const fetchAllUsers = createAsyncThunk(
  'user/allUsers',
  async ({ page}) => {
    const response = await getAllUsers({ page });
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);


export const fetchCreateUser = createAsyncThunk(
  'user/create',
  async ({ userdata }) => {
    const response = await create({ userdata});
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const fetchUpdateUser = createAsyncThunk(
  'user/update',
  async ({ userdata }) => {
    const response = await update({ userdata});
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const fetchDeleteUser = createAsyncThunk(
  'user/delete',
  async ({ userId }) => {
    const response = await deleteUser({ userId});
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);



export const userSlice = createSlice({
  name: 'user',
  initialState:{
    value: 0,
    loadingText:"Sign in",
    isAuthenticated:false,
    responseMsg:null,
    loggedUser:null,
    fetchingTextUser:null,
    users:[],
    currentPage: 1,
    totalPages: 1,
    totalRecords: 0,
    loading: false,
    isUserCreate:null,
    isSubmitting:false,
    userPermissions:[],
    permissionsLoaded:false
  },
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
   setAuthFromStorage: (state, action) => {
      state.token = action.payload.token;
      state.isAuthenticated = true;
       state.userPermissions = action.payload.permissions || [];
      state.permissionsLoaded = true;
    },
    setUpdateStatus: (state, action) => {
      state.isUserCreate = null;
      state.isSubmitting=false;
     
    },
    
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(fetchUserLogin.pending, (state) => {
        state.loadingText = 'Wait...';
      })
      .addCase(fetchUserLogin.fulfilled, (state, action) => {
        state.loadingText = 'Sign in';
        state.loggedUser = action.payload.data.user;
        state.isAuthenticated = true;
        state.userPermissions = action.payload.data.user.permissions;
        state.permissionsLoaded = true;
        sessionStorage.setItem("auth_token", action.payload.data.access_token);
        sessionStorage.setItem("user_permissions", JSON.stringify(action.payload.data.user.permissions));
        sessionStorage.setItem("token_version", action.payload.data.user.token_version);
        
      }).addCase(fetchUserLogin.rejected, (state ,action) => { 
        state.loadingText = 'Sign in';
        state.responseMsg = action.error.message;
       }) 
       
       .addCase(fetchUserLogout.pending, (state) => {
        state.loadingText = 'Wait...';
      })
      .addCase(fetchUserLogout.fulfilled, (state, action) => {
          state.loadingText = 'Sign in';
          state.loggedUser = null;
          state.isAuthenticated = false;
          state.userPermissions = [];
          state.permissionsLoaded = false;
          sessionStorage.removeItem("auth_token");
          sessionStorage.removeItem("user_permissions");
          sessionStorage.removeItem("token_version");

      }).addCase(fetchUserLogout.rejected, (state ,action) => { 
        state.responseMsg = action.error.message;
      })
      
      .addCase(fetchAllUsers.pending, (state) => {
         state.loading = true;       
        state.fetchingTextUser = 'Processing...';
      })
      .addCase(fetchAllUsers.fulfilled, (state, action) => {
        state.loading = false;
          state.fetchingTextUser = action.payload.data.pagination.total;
          state.users = action.payload.data.users;
          state.currentPage = action.payload.data.pagination.current_page;
        state.totalPages = action.payload.data.pagination.last_page;
        state.totalRecords = action.payload.data.pagination.total;
      }).addCase(fetchAllUsers.rejected, (state ,action) => { 
          state.loading = false;
          state.fetchingTextUser = action.error.message;
      })
      
      .addCase(fetchCreateUser.pending, (state) => {
        state.isUserCreate = 'pending';
        state.isSubmitting = true;
      })
      .addCase(fetchCreateUser.fulfilled, (state, action) => {
          state.isUserCreate = 'create';
           state.isSubmitting = false;
      }).addCase(fetchCreateUser.rejected, (state ,action) => {
        state.isUserCreate = 'error';
      })
      
       .addCase(fetchUpdateUser.pending, (state) => {
        state.isUserCreate = 'pending';
        state.isSubmitting = true;
      })
      .addCase(fetchUpdateUser.fulfilled, (state, action) => {
          state.isUserCreate = 'update';
          state.isSubmitting = false;
      }).addCase(fetchUpdateUser.rejected, (state ,action) => {
        state.isUserCreate = 'error';
      })
      
      .addCase(fetchDeleteUser.pending, (state) => {
        state.isUserCreate = 'pending';
      })
      .addCase(fetchDeleteUser.fulfilled, (state, action) => {
          state.isUserCreate = 'delete';
      }).addCase(fetchDeleteUser.rejected, (state ,action) => {
        state.isUserCreate = 'error';
      })
      ;
      
  },
});

export const { setAuthFromStorage , setUpdateStatus} = userSlice.actions;


export default userSlice.reducer;
