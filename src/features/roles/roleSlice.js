import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import { create, deleteRole, getAllRoles, update } from './rolesApi';


export const fetchAllRoles = createAsyncThunk(
  'role/allRoles',
  async ({ page}) => {
    const response = await getAllRoles({ page });
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);


export const fetchCreateRole = createAsyncThunk(
  'role/create',
  async ({ roleData }) => {
    const response = await create({ roleData});
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const fetchUpdateRole = createAsyncThunk(
  'role/update',
  async ({ roleData }) => {
    const response = await update({ roleData});
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const fetchDeleteRole = createAsyncThunk(
  'role/delete',
  async ({ Id }) => {
    const response = await deleteRole({ Id});
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);


export const roleSlice = createSlice({
  name: 'roles',
  initialState:{
    roles:[],
    currentPage: 1,
    totalPages: 1,
    totalRecords: 0,
    loading: false,
    isRoleCreate:null,
    isSubmitting:false
  },
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
   setAuthFromStorage: (state, action) => {
      state.token = action.payload.token;
      state.isAuthenticated = true;
    },
    setUpdateStatus: (state, action) => {
      state.isRoleCreate = null;
    },
    setCurrentPage: (state, action) => {
      state.currentPage = action.payload;
    },
    
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
    
      .addCase(fetchAllRoles.pending, (state) => {
         state.loading = true;       
      })
      .addCase(fetchAllRoles.fulfilled, (state, action) => {
          state.loading = false;
          state.roles = action.payload.data.roles;
          state.currentPage = action.payload.data.pagination.current_page;
        state.totalPages = action.payload.data.pagination.last_page;
        state.totalRecords = action.payload.data.pagination.total;
      }).addCase(fetchAllRoles.rejected, (state ,action) => { 
          state.loading = false;
      })
      
      .addCase(fetchCreateRole.pending, (state) => {
        state.isRoleCreate = 'pending';
        state.isSubmitting = true;
      })
      .addCase(fetchCreateRole.fulfilled, (state, action) => {
          state.isRoleCreate = 'create';
          state.isSubmitting = false;
      }).addCase(fetchCreateRole.rejected, (state ,action) => {
        state.isRoleCreate = 'error';
      })
      
       .addCase(fetchUpdateRole.pending, (state) => {
        state.isRoleCreate = 'pending';
        state.isSubmitting = true;
      })
      .addCase(fetchUpdateRole.fulfilled, (state, action) => {
          state.isRoleCreate = 'update';
          state.isSubmitting = false;
      }).addCase(fetchUpdateRole.rejected, (state ,action) => {
        state.isRoleCreate = 'error';
      })
      
      .addCase(fetchDeleteRole.pending, (state) => {
        state.isRoleCreate = 'pending';
      })
      .addCase(fetchDeleteRole.fulfilled, (state, action) => {
          state.isRoleCreate = 'delete';
      }).addCase(fetchDeleteRole.rejected, (state ,action) => {
        state.isRoleCreate = 'error';
      })
      ;
      
  },
});

export const { setAuthFromStorage , setUpdateStatus , setCurrentPage} = roleSlice.actions;


export default roleSlice.reducer;
