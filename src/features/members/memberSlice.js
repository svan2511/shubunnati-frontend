import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import { create, deleteMember, getAllMembers, update } from './memberApi';

export const fetchAllMembers = createAsyncThunk(
  'member/allMembers',
  async ({ token, page}) => {
    const response = await getAllMembers({ token, page });
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

// export const fetchGroupedPermissions = createAsyncThunk(
//   'permission/groupedPermissions',
//   async (token) => {
//     const response = await getAllGroupedPermissions(token);
//     // The value we return becomes the `fulfilled` action payload
//     return response.data;
//   }
// );


export const fetchCreateMember = createAsyncThunk(
  'member/create',
  async ({ token,mData }) => {
    const response = await create({token , mData});
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const fetchUpdateMember = createAsyncThunk(
  'member/update',
  async ({ token,mData }) => {
    const response = await update({token , mData});
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const fetchDeleteMember = createAsyncThunk(
  'member/delete',
  async ({ token,Id }) => {
    const response = await deleteMember({token , Id});
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);



export const memberSlice = createSlice({
  name: 'member',
  initialState:{
    value: 0,
    members:[],
    currentPage: 1,
    totalPages: 1,
    totalRecords: 0,
    loading: false,
    isMemberCreate:null
  },
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
   setAuthFromStorage: (state, action) => {
      state.token = action.payload.token;
      state.isAuthenticated = true;
    },
    setUpdateStatus: (state, action) => {
      state.isMemberCreate = null;
    },
    setCurrentPage: (state, action) => {
      state.currentPage = action.payload;
    },
    
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
     
      .addCase(fetchAllMembers.pending, (state) => {
         state.loading = true;       
      })
      .addCase(fetchAllMembers.fulfilled, (state, action) => {
          state.loading = false;
          state.members = action.payload.data.members;
          state.currentPage = action.payload.data.pagination.current_page;
        state.totalPages = action.payload.data.pagination.last_page;
        state.totalRecords = action.payload.data.pagination.total;
      }).addCase(fetchAllMembers.rejected, (state ,action) => { 
          state.loading = false;
      })
      
      .addCase(fetchCreateMember.pending, (state) => {
        state.isMemberCreate = 'pending';
      })
      .addCase(fetchCreateMember.fulfilled, (state, action) => {
          state.isMemberCreate = 'create';
      }).addCase(fetchCreateMember.rejected, (state ,action) => {
        state.isMemberCreate = 'error';
      })
      
       .addCase(fetchUpdateMember.pending, (state) => {
        state.isMemberCreate = 'pending';
      })
      .addCase(fetchUpdateMember.fulfilled, (state, action) => {
          state.isMemberCreate = 'update';
      }).addCase(fetchUpdateMember.rejected, (state ,action) => {
        state.isMemberCreate = 'error';
      })
      
      .addCase(fetchDeleteMember.pending, (state) => {
        state.isMemberCreate = 'pending';
      })
      .addCase(fetchDeleteMember.fulfilled, (state, action) => {
          state.isMemberCreate = 'delete';
      }).addCase(fetchDeleteMember.rejected, (state ,action) => {
        state.isMemberCreate = 'error';
      });
      
  },
});

export const { setAuthFromStorage , setUpdateStatus , setCurrentPage} = memberSlice.actions;


export default memberSlice.reducer;
