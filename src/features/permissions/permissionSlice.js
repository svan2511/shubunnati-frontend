import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import { create, deletePermission, getAllGroupedPermissions, getAllPermissions, update } from './permissionApi';



export const fetchAllPermissions = createAsyncThunk(
  'permission/allPermissions',
  async ({ token, page}) => {
    const response = await getAllPermissions({ token, page });
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const fetchGroupedPermissions = createAsyncThunk(
  'permission/groupedPermissions',
  async (token) => {
    const response = await getAllGroupedPermissions(token);
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);


export const fetchCreatePermission = createAsyncThunk(
  'permission/create',
  async ({ token,pData }) => {
    const response = await create({token , pData});
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const fetchUpdatePermission = createAsyncThunk(
  'permission/update',
  async ({ token,pData }) => {
    const response = await update({token , pData});
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const fetchDeletePermission = createAsyncThunk(
  'permission/delete',
  async ({ token,Id }) => {
    const response = await deletePermission({token , Id});
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);



export const permissionSlice = createSlice({
  name: 'permission',
  initialState:{
    value: 0,
    permissions:[],
    currentPage: 1,
    totalPages: 1,
    totalRecords: 0,
    loading: false,
    isPermissionCreate:null,
    groupedPermissions:[]
  },
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
   setAuthFromStorage: (state, action) => {
      state.token = action.payload.token;
      state.isAuthenticated = true;
    },
    setUpdateStatus: (state, action) => {
      state.isPermissionCreate = null;
    },
    setCurrentPage: (state, action) => {
      state.currentPage = action.payload;
    },
    
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
     
      .addCase(fetchAllPermissions.pending, (state) => {
         state.loading = true;       
      })
      .addCase(fetchAllPermissions.fulfilled, (state, action) => {
          state.loading = false;
          state.fetchingTextUser = action.payload.data.pagination.total;
          state.permissions = action.payload.data.permissions;
          state.currentPage = action.payload.data.pagination.current_page;
        state.totalPages = action.payload.data.pagination.last_page;
        state.totalRecords = action.payload.data.pagination.total;
      }).addCase(fetchAllPermissions.rejected, (state ,action) => { 
          state.loading = false;
      })
      
      .addCase(fetchCreatePermission.pending, (state) => {
        state.isPermissionCreate = 'pending';
      })
      .addCase(fetchCreatePermission.fulfilled, (state, action) => {
          state.isPermissionCreate = 'create';
      }).addCase(fetchCreatePermission.rejected, (state ,action) => {
        state.isPermissionCreate = 'error';
      })
      
       .addCase(fetchUpdatePermission.pending, (state) => {
        state.isPermissionCreate = 'pending';
      })
      .addCase(fetchUpdatePermission.fulfilled, (state, action) => {
          state.isPermissionCreate = 'update';
      }).addCase(fetchUpdatePermission.rejected, (state ,action) => {
        state.isPermissionCreate = 'error';
      })
      
      .addCase(fetchDeletePermission.pending, (state) => {
        state.isPermissionCreate = 'pending';
      })
      .addCase(fetchDeletePermission.fulfilled, (state, action) => {
          state.isPermissionCreate = 'delete';
      }).addCase(fetchDeletePermission.rejected, (state ,action) => {
        state.isPermissionCreate = 'error';
      })

      .addCase(fetchGroupedPermissions.pending, (state) => {
       
      })
      .addCase(fetchGroupedPermissions.fulfilled, (state, action) => {
          state.groupedPermissions = action.payload.data.permissions;
      }).addCase(fetchGroupedPermissions.rejected, (state ,action) => {
        
      })

      ;
      
  },
});

export const { setAuthFromStorage , setUpdateStatus , setCurrentPage} = permissionSlice.actions;


export default permissionSlice.reducer;
